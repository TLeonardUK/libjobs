<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libjobs: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libjobs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libjobs Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="fragment"><div class="line">.__   .__ ___.         __        ___.            </div><div class="line">|  |  |__|\_ |__      |__|  ____ \_ |__    ______</div><div class="line">|  |  |  | | __ \     |  | /  _ \ | __ \  /  ___/</div><div class="line">|  |__|  | | \_\ \    |  |(  &lt;_&gt; )| \_\ \ \___ \ </div><div class="line">|____/|__| |___  //\__|  | \____/ |___  //____  &gt;</div><div class="line">               \/ \______|            \/      \/ </div></div><!-- fragment --><h2>About Libjobs</h2>
<p>Libjobs is a simple C++ library that is designed to allow multi-threaded coroutine-style job management and scheduling (implemented using fibers). It currently runs on Windows, XboxOne, PS4, Nintendo Switch, and is fairly straight forward to port to other platforms as it uses relatively little platform-dependent code.</p>
<p>Implementing jobs using fibers provides a variety of benefits. Primarily it provides the developer the illusion they are working with threads, and allows them to do things that would typically block the cpu (waiting on sync primitives, sleeping, waiting for tasks to complete, wait for io, etc), without actually doing so. Allowing optimal usage of available processing power.</p>
<p>Architecturally libjobs is designed to run a fixed number of worker threads (preferably one per core), with each thread picking up and executing jobs. Jobs are cooperatively scheduled, so whenever a blocking event occurs, the worker thread stops executing it and starts running another job, while the waiting job is queued for re-execution when its wait condition completes. The library also supports different job and worker priorities so jobs can be appropriate ordered and split between different workers.</p>
<p>The library is designed for both high-performance and limited resources. Memory allocation (overridable with use defined allocation functions) is done during scheduler initialization and no memory is allocated beyond that point.</p>
<h2>Building</h2>
<p>The project uses cmake for building the library and examples. It's also been setup with a CMakeSettings.json file so it can be opened as a folder project in visual studio.</p>
<p>Building is identical to most cmake projects, check a cmake tutorial if you are unsure. The only caveat is that we cross-compile various platform builds. To make cmake build these you need to use the appropriate toolchain file (which are stored in cmake/Toolchain). You can pass these as parameters when configuring the project with cmake. eg.</p>
<p>-DCMAKE_TOOLCHAIN_FILE=cmake/Toolchain/PS4.cmake</p>
<h2>API Reference</h2>
<p>The library uses doxygen for its api reference. Once the project is build the output will be stored on docs/html.</p>
<h2>Basic Usage</h2>
<p>Examples of how to use the library are provided in docs/examples. Below is a brief explanation of the minimal steps required to run a job.</p>
<p>First a scheduler needs to be created, the scheduler is the responsible for managing the entire job system. Projects should use a single scheduler, though in theory multiple can be used concurrently. </p><div class="fragment"><div class="line"><a class="code" href="classjobs_1_1scheduler.html">jobs::scheduler</a> <a class="code" href="namespacejobs.html#ab8cd038ddce7c48eabbed1d0a3428ad7a499f31e79c00c9e8f61bdaadc5e82f45">scheduler</a>;</div></div><!-- fragment --><p>Next a thread pool should be added. A thread pool is a number of worker threads that will be spawned and will execute jobs which have a priority in thread-pools priority bit-mask. Multiple thread-pools can be created if you want to segregate specific jobs to specific workers (such as having a specific thread that only every takes time-critical jobs, or one that only takes long running jobs). </p><div class="fragment"><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#a0302314dbce01fbb3566c9ffe742adf7">add_thread_pool</a>(8, <a class="code" href="namespacejobs.html#a2116e27fa7d2a583aaaa7fcfe70f428daa181a603769c1f98ad927e7367c7aa51">jobs::priority::all</a>);</div></div><!-- fragment --><p>Next a fiber pool should be created. Fibers store the context of individually executing jobs. You should allocate enough fibers such that all concurrently active jobs are able to allocate one. Fibers have a fixed stack-size and jobs can be given a minimum stack-size they require, and will not use any fibers that have less than it. Fibers can be split up into different pools of varying stack-sizes to optimally allocate memory. </p><div class="fragment"><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#a5dc5dae47a7903d648cb03172b33c9d6">add_fiber_pool</a>(10, 16 * 1024);</div></div><!-- fragment --><p>Next the scheduler should be initialized. It is at this point that all memory will be allocated and all fibers and thread workers will be created. </p><div class="fragment"><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#ad6090dbccd0375e37605cfcb31a6ef39">init</a>();</div></div><!-- fragment --><p>Jobs can then be created, assigned a work-function and dispatched for execution. </p><div class="fragment"><div class="line"><a class="code" href="classjobs_1_1job__handle.html">jobs::job_handle</a> job_1;</div><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#adb677b86975a1ce1d9e6cee58669d5e6">create_job</a>(job_1);</div><div class="line"></div><div class="line">job_1.<a class="code" href="classjobs_1_1job__handle.html#a62de9f5dba6c12be83d50ed980535b88">set_work</a>([=]() { printf(<span class="stringliteral">&quot;Example job executed\n&quot;</span>); });</div><div class="line">job_1.<a class="code" href="classjobs_1_1job__handle.html#a3a1b791bc9b7a7ac0b3bc569f172a0b0">dispatch</a>();</div></div><!-- fragment --><p>Various API's exist for waiting for individual jobs, counters or other syncronization primitives. At a minimum in this example we wait until all jobs have finished by waiting for the scheduler to go idle. </p><div class="fragment"><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#a02d4eabd757213f9f3ec4c190ef2257d">wait_until_idle</a>();</div></div><!-- fragment --><h2>Synchronization</h2>
<p>Synchronization is primarily done in three ways, waiting for jobs, waiting for counters and other sync primitives, and explicit dependencies.</p>
<h3>Explicit Dependencies</h3>
<p>Before jobs are dispatched they can have predecessor and successor jobs added to them. The scheduler will never attempt to queue a job for execution until its dependencies are met. This is the cheapest form of synchronization and provides very explit control over execution order.</p>
<div class="fragment"><div class="line"><a class="code" href="classjobs_1_1job__handle.html">jobs::job_handle</a> job_1;</div><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#adb677b86975a1ce1d9e6cee58669d5e6">create_job</a>(job_1);</div><div class="line"></div><div class="line">job_1.<a class="code" href="classjobs_1_1job__handle.html#a49c66504ba46072c56cf1053a7eec8ba">add_predecessor</a>(other_job_handle);</div><div class="line">job_1.<a class="code" href="classjobs_1_1job__handle.html#ac999360c9c6b8e2102c10159eac0a4a3">add_successor</a>(another_job_handle);</div></div><!-- fragment --><h3>Waiting For Jobs</h3>
<p>Both jobs and external-threads can wait for execution to finish on individual jobs using the wait_for method of a job handle. For a job, this will cause it to be requeued until the dependent job is finished, for external-threads this will cause a block. Timeouts are also supported.</p>
<div class="fragment"><div class="line">job_1.<a class="code" href="classjobs_1_1job__handle.html#a70da72af5b6a2d7aa7e58ebd7b8d8d5d">wait</a>(<a class="code" href="structjobs_1_1timeout.html#aa9aa3cdebb3dd5f66e95029b6179144f">jobs::timeout::infinite</a>);</div></div><!-- fragment --><h3>Waiting For Counters</h3>
<p>Counters provide a simple and straight-forward way to synchronize operations between multiple jobs, they also provide the building blocks that the other synchronisation primitives build of (events/semaphores/etc).</p>
<p>Internally a counter is just an unsigned atomic integer. The integer can be added to, set or subtracted from. Jobs can wait until the integer equals a given value. Counters can never go below zero so attempting to subtract a value larger that it's current value will cause the job to wait until enough has been added to the counter to no longer cause the subtraction to go negative.</p>
<p>You can use this to synchronize large numbers of jobs at the same time:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a counter to synchronize with.</span></div><div class="line"><a class="code" href="classjobs_1_1counter__handle.html">jobs::counter_handle</a> counter_1;</div><div class="line">scheduler.<a class="code" href="classjobs_1_1scheduler.html#a71779aafde74ca64c59956fb3223a562">create_counter</a>(counter_1);</div><div class="line"></div><div class="line"><span class="comment">// ... Spawn 100 jobs that each increment counter_1 when they complete.</span></div><div class="line"></div><div class="line"><span class="comment">// Block until all jobs have completed.</span></div><div class="line">counter_1.<a class="code" href="classjobs_1_1counter__handle.html#a333ceb5f72507656194ad7fbfd69b384">wait_for</a>(100, <a class="code" href="structjobs_1_1timeout.html#aa9aa3cdebb3dd5f66e95029b6179144f">jobs::timeout::infinite</a>);</div></div><!-- fragment --><p>Counters, while fundementally simple, provide an immense amount of flexibility.</p>
<h2>Contact Details</h2>
<p>Any questions you are welcome to send me an email;</p>
<p>Tim Leonard <a href="#" onclick="location.href='mai'+'lto:'+'me@'+'ti'+'mle'+'on'+'ard'+'.u'+'k'; return false;">me@ti<span style="display: none;">.nosp@m.</span>mleo<span style="display: none;">.nosp@m.</span>nard.<span style="display: none;">.nosp@m.</span>uk</a></p>
<h2>Credits / Further Reading</h2>
<p>Naughty Dog use a similar fiber based job system in their engine, and gave a great GDC talk a few years ago that covers their implementation. It's one of the inspirations for this library. <a href="https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine">https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine</a></p>
<p>Housemarque also have an very nice fiber based in-house engine which I had the pleasure of working with when porting resogun/dead-nation, which was heavily instrumental in me experimenting further with fibers. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 15 2019 13:00:15 for libjobs by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
